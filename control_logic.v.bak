module control_logic (
			clk,
			control_fixed_0,
			control_go_0,
			control_write_base_0,
			control_write_length_0,
			user_buffer_input_0,
			user_write_buffer_0,
			control_done_0,
			user_buffer_full_0,
			A,
			D,
			we,
			enable,
			vpa,
			reset
			key0
				);
				
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// Clock ///////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////	
		
input clk;

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// Outputs /////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

output reg control_fixed_0;
output reg control_go_0;
output reg [31:0] control_write_base_0;
output reg [31:0] control_write_length_0;
output reg [31:0] user_buffer_input_0;
output reg user_write_buffer_0;
output reg we; // Read/~Write
output reg enable; // Enable
output reg reset; // Reset

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// Inputs //////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

input wire control_done_0;
input wire user_buffer_full_0;
input wire [9:0] A; // Address
input wire vpa; // Valid peripheral insert check
input wire key0; // Key

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// Bidirectional ///////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

inout [7:0] D; // Data

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// Regs ////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

reg [0:24] count;
reg [31:0] temp;
reg [7:0] dataw;

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// Wires ///////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

wire [7:0] data;
wire [4:0] address;
wire [1:0] port;

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// Assignments /////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

// if enable set to low, write enable goes low, else write enable high
assign we = (~enable) ? 0 : 1; 
// if write enable goes low, data becomes output (write), else data tri-state
assign D = (~we) ? dataw : 8'bzzzz_zzzz; 
//if write enable goes high, data becomes input, else zero
assign data = (we) ? D : 8'd0;
//{a4, a3, a2, a1, a0}; // a4 MSB, a0 LSB
assign address = {A[4:0]};
//{a6, a5}; // a6 MSB
assign port = {A[6:5]};
// if key press, reset, else not
assign reset = (key0) ? 0 : 1;

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// Initialisation //////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

initial begin
	count = 25'd1; // counter
	user_write_buffer_0 = 1'b0; // Write qualifer. Must be asserted to write data in.
	control_fixed_0 = 1'b0; // Determines whether the master address will increment
	control_write_base_0 = 32'h10004000; //base address
	control_write_length_0 = 32'd12; //  multiple of datawidth in bytes //  Number of Bytes to transfer
	temp = 32'd30554432; // high value to delay
end

always@(posedge clk)
begin

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// Counter /////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

	if (count<temp) // perform a burst write every time count reaches temp
	begin
		count <= count+25'd1; // increment counter
	end
	
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// Reset ///////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

	if (~reset) 
	begin
		count <= 25'd0;
	end
	
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// Data read ///////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

						control_go_0 <= 1'b0; 
						
						if(count==temp && !user_buffer_full_0) // start transfer condition
							begin
									user_buffer_input_0 <= {27â€™d0,~address}; // module value
									user_write_buffer_0 <= 1'b1; //write qualifier
									control_go_0 <= 1'b1; //get things started
									count <= temp+1;
							end
							
						if(count==(temp+1) && !user_buffer_full_0)
							begin
									user_buffer_input_0 <= port[1:0]; // port value
									count <= temp+2;
							end
							
						if(count==(temp+2) && !user_buffer_full_0)
							begin
									user_buffer_input_0 <= data; // data value
									count <= temp+3;
							end
							
						if(count==(temp+3) && !user_buffer_full_0)
							begin
									count <= 0;
									control_go_0 <= 1'b0; //reset control go
									user_write_buffer_0 <= 1'b0; //reset user write buffer
							end
							
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// Data write //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////














end

endmodule


